次にレコードのロックですが、データベースはデータの整合性を担保するため、トランザクション中に更新がかかったレコードのロックを獲得し、他のトランザクションからの更新をブロックする機構が備わっています。今回の課題で利用するSQLだと、INSERTは挿入したレコード自身の、UPDATE, DELETEはそれぞれ更新／削除したレコードのロックを獲得します。具体例を見てみましょう

まずターミナルからMySQLサーバーに入り、次のようにクエリを実行します
※ ここで ID = 1 のレコードがすでに存在しているものとします

BEGIN;
UPDATE `users` SET `first_name` = 'New Value' WHERE `id` = 1;
この状態で別のターミナルから同じようにMySQLサーバーに入り、以下のクエリを実行してみましょう。制御が返らずハングするはずです

DELETE `users` WHERE `id` = 1;
元のターミナルに戻り、トランザクションをコミットします。すると更新が反映された直後、2つめのターミナルでも制御が返ってきてDELETEが成功します

COMMIT;
で、今回はPUTリクエストのSELECT文でロックを獲得し、SELECTが実行されたらトランザクションがコミットされるまでDELETE文をブロックしないといけません。このときに使うのがレコードの読み取りロック（Locking Read）です。
https://dev.mysql.com/doc/refman/8.0/ja/innodb-locking-reads.html

具体的には、次のようにSELECT文の最後に FOR UPDATE を追加することで、トランザクション中で有効なロックを獲得できます

SELECT ... FROM `users` WHERE `id` = 1 FOR UPDATE;
最初のSELECT文を↑のように変更するだけで、レコードロックを獲得できるようになります。

さて、長くなりましたが実施すべき変更は以下の2つです 😌

PUTリクエストの各クエリを実行するためにトランザクションを使う
PUTリクエストの一回目のSELECT時にレコードロックをする
